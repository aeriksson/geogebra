/* 
GeoGebra - Dynamic Mathematics for Everyone
Copyright Markus Hohenwarter, http://www.geogebra.org

This file is part of GeoGebra.

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by 
the Free Software Foundation; either version 2 of the License, or 
(at your option) any later version.
*/

/*
 * Parser.jj
 * javacc definition file to generate Parser.java
 * <BR> <BR>
 * This class provides a static function to  
 * parse a String and return an appropriate ValidExpression.
 * Direct subclasses of ValidExpression are: 
 * Command, Equation (in x, y), Parametric, Vector (for cartesian and polar points),
 * ExpressionNode (for number or vector arithmetic expressions)
 *
 * <BR><BR>
 * Some examples of possible recognized input:<BR>
 * Point   <CODE> P = (3,4) </CODE><BR>
 * Point   <CODE> P = (7; 20?) </CODE><BR>
 * Line    <CODE> g: X = (3,4) + t (7,2) </CODE><BR>
 * Line    <CODE> g: y = 3x - 9 </CODE><BR>
 * Line    <CODE> h: 5x + 7y = -2 </CODE><BR>
 * Circle  <CODE> k: (x-5)^2 + (y-2)^2 = 25 </CODE><BR>
 * Circle  <CODE> k: (x-5)? + (y-2)? = 25 </CODE><BR>
 * Conic   <CODE> c: 5x^2 - 7y^2 + 6xy - 3x + 2y = 7 </CODE>
 * Command <CODE> P = Intersect[ g, h ] </CODE>
 * Number  <CODE> r = 25 </CODE>
 * <BR><BR>
 * All arithmetic expressions (operators: +, -, *, /, ^) are 
 * valid as long as they obey the following rules:
 * Variables are x or y. Divisors and Exponents must be constant
 * numbers. The "*" operator may be omitted.
 *
 * @author Markus Hohenwarter
 * @version 10.4.2004
 */   

PARSER_BEGIN(Parser)
package geogebra.common.kernel.parser;

import geogebra.common.kernel.Construction;
import geogebra.common.kernel.arithmetic.*;
import geogebra.common.kernel.arithmetic3D.MyVec3DNode;
import geogebra.common.kernel.arithmetic3D.Vector3DValue;
import geogebra.common.kernel.commands.Commands;
import geogebra.common.kernel.geos.GeoElement;
import geogebra.common.kernel.geos.GeoElementSpreadsheet;
import geogebra.common.kernel.geos.GeoFunctionNVar;
import geogebra.common.kernel.geos.GeoNumeric;
import geogebra.common.kernel.geos.GeoVec2D;
import geogebra.common.kernel.parser.ParserInterface;
import geogebra.common.kernel.StringTemplate;
import geogebra.common.main.MyError;
import geogebra.common.main.Localization;
import geogebra.common.main.MyParseError;
import geogebra.common.main.BracketsError;
import geogebra.common.util.StringUtil;
import geogebra.common.util.Unicode;
import geogebra.common.kernel.Kernel;
import geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce;
import geogebra.common.main.App;
import geogebra.common.plugin.Operation;

import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Vector;


public class Parser implements ParserInterface{

    private Kernel kernel;
    private App app;
    private Localization loc;
    private boolean GeoGebraCASParsing = false;
    private boolean ExternalCASParsing = false;
	private boolean MPReduceParsing = false;
	private ArrayList<ExpressionNode > undecided = new ArrayList<ExpressionNode >();
    
    public Parser(Kernel kernel, Construction cons) {
    	 this ( new java.io.StringReader("") ); // dummy stream for parser initing
         this.kernel = kernel;
         app = kernel.getApplication();
         loc = app.getLocalization();
    }   
    
    // reset for new parsing
    public void myReInit(String parseString) throws ParseException {
        if(StringUtil.checkBracketsBackward(StringUtil.ignoreIndices(parseString))>=0){
          throw new BracketsError(loc,parseString);
        }
    	ReInit(new java.io.StringReader(parseString));    	
    	GeoGebraCASParsing = false;
    	ExternalCASParsing = false;
    	MPReduceParsing = false;
    	undecided.clear();
    }

    /**
     * Parses a String and returns a ValidExpression Object     
     */
    public ValidExpression parseGeoGebraExpression(String parseString) throws ParseException {           
        myReInit( parseString );                         
        ValidExpression ret = buildValidExpression();
        processUndecided();
        return ret;     
    }
    
     /**
     * Parses a String and returns a ValidExpression Object     
     */
    public ValidExpression parseGeoGebraCAS(String parseString) throws ParseException {           
        myReInit( parseString );
        // parse x^2 + y^2 as an expression and don't throw Incomplete Equation error
        GeoGebraCASParsing = true;                        
        ValidExpression ret = buildCASExpression();
        return ret;     
    }

    /**
     * Parses a MPReduce String and returns a ValidExpression Object     
     */
    public ValidExpression parseMPReduce(String parseString) throws ParseException {           
        myReInit( parseString ); 
        ExternalCASParsing = true;
        MPReduceParsing = true;                     
        return buildMPReduceExpression();     
    }
    
    /**
     * Parses a String and returns a Function Object     
     */
    public Function parseFunction(String parseString) 
    throws ParseException {    
        myReInit( parseString );                           
        Function ret = function();
        processUndecided();
        return ret;           
    }

    /**
     * Parses a String and returns a Function Object     
     */
    public FunctionNVar parseFunctionNVar(String parseString) 
    throws ParseException {    
        myReInit( parseString );                           
        FunctionNVar ret = functionNVar();
        processUndecided();
        return ret;           
    }
    
    /**
     * Parses a String and returns an ExpressionNode Object     
     */
    public ExpressionNode parseCmdExpression(String parseString) 
    throws ParseException {    
        myReInit(parseString );                           
        ExpressionNode ret = cmdexpression();
        processUndecided();
        return ret;           
    }
    
    /**
     * Parses a String and returns an ExpressionNode Object     
     */
    public ExpressionNode parseExpression(String parseString) 
    throws ParseException {    
        myReInit( parseString);                           
        ExpressionNode ret = expression();
        processUndecided();
        return ret;   
    }
    
    /**
     * Parses a String if it is a label
     */
    public String parseLabel(String parseString) 
    throws ParseException {    
        myReInit(parseString );                           
        return label().image;      
    }
    private ExpressionNode makePower(ExpressionValue v,ExpressionValue e){
  		if(v.isExpressionNode() && ((ExpressionNode)v).getOperation()
  			==Operation.MULTIPLY_OR_FUNCTION){
    		return new ExpressionNode(kernel,((ExpressionNode)v).getLeft(),Operation.MULTIPLY,
    			new ExpressionNode(kernel,((ExpressionNode)v).getRight(),Operation.POWER,e));
  		}
  		return new ExpressionNode(kernel,v,Operation.POWER,e);
	}

	private void processUndecided(){
		for(ExpressionNode en: undecided)
			en.setOperation(Operation.MULTIPLY);
		undecided.clear();	  
 	}

 	private ExpressionNode buildOpNode(Operation op,MyList list){
 	  switch(list.size())
 	  {
 	    case 1:return new ExpressionNode(kernel,list.getListElement(0),op,null);
 	    case 2:return new ExpressionNode(kernel,list.getListElement(0),op,list.getListElement(1));
 	    //for beta regularized
 	    case 3:return new ExpressionNode(kernel,new MyNumberPair(kernel,list.getListElement(0),
 	    list.getListElement(1)),op,list.getListElement(2));
 	    //for sum (from CAS)
 	    case 4:return new ExpressionNode(kernel,new MyNumberPair(kernel,list.getListElement(0),
 	    list.getListElement(1)),op,new MyNumberPair(kernel,list.getListElement(2),
 	    list.getListElement(3)));
 	    default:return null;
 	  }
 	}

	private ExpressionNode polysToFunctionVariables(ExpressionNode en)
	{
			TreeSet<String> vars = en.getPolynomialVars();
          	switch (vars.size()) {
          		case 0: break;
          		case 1: // single var function
	        		return new ExpressionNode(kernel, new Function(en, new FunctionVariable(kernel, vars.first())));

				default: // multivariate function
					FunctionVariable [] funs = new FunctionVariable[vars.size()];    	
					int i=0;
			    	for (String var : vars) {
			    		funs[i++] = new FunctionVariable(kernel, var);
			    	}
			    	return new ExpressionNode(kernel, new FunctionNVar(en, funs));
			    	
          	}
          	return en;
	  }
}
PARSER_END(Parser)



SKIP : {
    " " 
  | "\r"
  | "\t"
  | "\n"
}

TOKEN : {
    < EOL: ";" >
}

/* OPERATORS */
TOKEN :  {   
    < ASSIGNMENT: ( ":=") >
  | < DELAYED_ASSIGNMENT: ( "::=") >
  | < VERTICAL_BAR: "|" >
  | < NOT: ("\u00ac") > 
  | < OR:		("||" | "\u2228" ) >
  | < AND:		("&&" | "\u2227" ) >
  | < IMPLICATION:		("->" | "\u2192") >
  | < EQUAL_BOOLEAN: ("==" | "\u225f" ) >
  | < NOT_EQUAL: ("!=" | "\u2260" | "<>" ) >
  | < IS_ELEMENT_OF: "\u2208" >
  | < IS_SUBSET_OF: "\u2286" >
  | < IS_SUBSET_OF_STRICT: "\u2282" >
  | < SET_DIFFERENCE: "\\" >
  | < LESS:		"<" >
  | < GREATER:	">" >
  | < LESS_EQUAL: ("<=" | "\u2264") >
  | < GREATER_EQUAL: (">=" | "\u2265") >
 // | < INEQUALITY: ( < LESS > | < LESS_EQUAL > | < GREATER_EQUAL > | < GREATER > ) >
  | < PARALLEL: "\u2225" >
  | < PERPENDICULAR: "\u22a5" >
  | < EQUAL:    "=" >
  | < PLUS:     "+" >
  | < MINUS:    ("-"  | "\u2013" | "\u2212") >
  | < SUPERSCRIPT_MINUS: "\u207b" >
  | < POWER:    ("^" | "**") >  
    // dot operators for multiplication sign
  | < MULTIPLY: ("*" | "\u22c5" | "\u2219") >
  | < VECTORPRODUCT: "\u2297" >
  | < DIVIDE:   ("/" | "\u00f7") >
  | < FACTORIAL: "!" >  
  | < UNDEFINED: ( "?" | "\ufffd" | "Undefined" | "NaN" | "und" ) >
//  | < POWER0:   "\u2070" >
//  | < POWER1:   "\u00b9" >
//  | < SQUARED:  "\u00b2" >
//  | < CUBED:    "\u00b3" >
//  | < POWER4:   "\u2074" >
//  | < POWER5:   "\u2075" >
//  | < POWER6:   "\u2076" >
//  | < POWER7:   "\u2077" >
//  | < POWER8:   "\u2078" >
//  | < POWER9:   "\u2079" >
  | < POWERN: (<SUPERSCRIPT_MINUS>)? ( <INDEXDIGIT> )+ >
  | < #INDEXDIGIT:                                     // unicode digits
       [ "\u2070","\u2074"-"\u2079","\u00b9","\u00b2","\u00b3"] >
  | < PI:       ( "pi" | "Pi" | "\u03c0" | "%pi") >
  | < E:        ("\u212f" | "%e") > // Euler constant
  | < IMAGINARY: ("\u03af" | "%i") > // imaginary constant
  | < DEGREE:   ( "\u00b0" ) >
  | < INFINITY: ("\u221e" | "Infinity" | "inf" | "infinity") >
  | < MINUS_INFINITY: ("minf") >
  | < RAD:      "rad" >
  | < DERIVATIVE: "'" >
  | < TRUE:     ( "true" | "True" ) >
  | < FALSE:    ( "false" | "False" ) >
  | < DECIMAL_POINT:    ( "." | "\u066b" ) > // Arabic decimal point
  | < COMMA:    ( "," | "\u060c" ) > // Arabic comma
}

TOKEN : {      
  		< VARX: "x" >
  |		< VARY: "y" >
  |		< VARZ: "z" >
  |     < FLOAT:  (<INTEGER> | <DECIMAL_POINT>)+ > //deliberately trap eg 1.2.3.4 , 1..2 here, error then thrown in MyDouble.parseDouble()
  |     < EFLOAT: <FLOAT> ("E") (<PLUS> | <MINUS>)? <INTEGER> >
  |     < PERCENTAGE: <FLOAT> "%" >
  |     < INTEGER: ( <DIGIT> )+ >
  |     < #DIGIT:                                     // unicode digits
	       [
	        "\u0030"-"\u0039", // Roman
	        "\u0660"-"\u0669", // Arabic-Indic
	        "\u06f0"-"\u06f9", // Extended Arabic-Indic
	        "\u0966"-"\u096f", // Devanagari (Hindi)
	        "\u09e6"-"\u09ef", // Bengali
	        "\u0a66"-"\u0a6f", // Gurmukhi (Punjabi)
	        "\u0ae6"-"\u0aef", // Gujurati
	        "\u0b66"-"\u0b6f", // Oryia
	        "\u0be6"-"\u0bef", // Tamil
	        "\u0c66"-"\u0c6f", // Telugu
	        "\u0ce6"-"\u0cef", // Kannada
	        "\u0d66"-"\u0d6f", // Malayalam
	        "\u0e50"-"\u0e59", // Thai
	        "\u0ed0"-"\u0ed9", // Lao
	        "\u1040"-"\u1049", // Myanmar (Burmese)
	        "\u0f20"-"\u0f29", // Tibetan
	        "\u1b50"-"\u1b59", // Balinese
	        "\u1bb0"-"\u1bb9", // Sudanese
	        "\u1c40"-"\u1c49", // Lepcha
	        "\u1c50"-"\u1c59", // Ol Chiki
	        "\u17e0"-"\u17e9", // Khmer
	        "\u1810"-"\u1819", // Mongolian
	        "\ua8d0"-"\ua8d9"  // Saurashtra
	       ]	     
		> 
}   

TOKEN : { 
 	// labels for cells in the spreadsheet
 	<SPREADSHEET_LABEL: ("$")?(["A"-"Z"]|["a"-"z"])+("$")?(["0"-"9"])+ > // e.g. B12
 | 
 	// standard case: labels for GeoElements and command names
   < LABEL:  
    <LETTER> ( <LETTER> | <DIGIT> | "'" )* (<INDEX>)? (<LETTER> | <DIGIT>)*>
 // |  < #INDEX:  "_" (  <CHAR>  | ("{" (<CHAR>)+ "}") )  >  
 |  < #INDEX:  "_" (  <CHAR>  | ("{" (~["}"])+ "}" ) )  >  
 | < #LETTER:  // unicode letters
       [
        "$", // for absolute references in the spreadsheet
        "\u0041"-"\u005a",      //upper case (A-Z)
        "\u0061"-"\u007a",      //lower case (a-z)
        "\u00b7",   			// middle dot (for Catalan)
        "\u00c0"-"\u00d6",      //accentuated letters
        "\u00d8"-"\u00f6",		//accentuated letters
        "\u00f8"-"\u01bf",		//accentuated letters
        "\u01c4"-"\u02a8",		//accentuated letters
        "\u0391"-"\u03f3", 		// Greek 
       	"\u0401"-"\u0481",		// Cyrillic
        "\u0490"-"\u04f9",		// Cyrillic
        "\u0531"-"\u1ffc", 	    // a lot of signs (Arabic, accentuated, ...)
        "\u3041"-"\u3357", 	 	// Asian letters	 
        "\u4e00"-"\ud7a3",		// Asian letters
        "\uf71d"-"\ufa2d",		// Asian letters
        "\ufb13"-"\ufdfb",		// Armenian, Hebrew, Arabic
        "\ufe80"-"\ufefc",		// Arabic
        "\uff66"-"\uff9d",		// Katakana
        "\uffa1"-"\uffdc"		// Hangul
       ] >
       
}



// labels for function names
TOKEN: {
    < X_FUNC:  ("x" | "xcoord") + ("("|"[")>
|	< Y_FUNC:  ("y" | "ycoord")  + ("("|"[")> 
|	< Z_FUNC:  ("z" | "zcoord")  + ("("|"[")>
|	< MAT_FUNC:  "mat("  > // may be returned by MPReduce
|	< RANDOM_FUNC:  "random()"  >
|   < MP_POLARTOPOINT: "polartopoint\u00a7(" > // may be returned by MPreduce
|  	< SQRT_SHORT: "\u221a" > 
| 	< FUNCTION_LABEL: (<SPREADSHEET_LABEL> | <LABEL> ) ("("|"[") >
| 	< FUNCTION_POWER_LABEL: (<SPREADSHEET_LABEL> | <LABEL> ) (< POWERN > )("("|"[") >
}

 TOKEN : {
 < TEXT: "\""  (<CHAR>)* "\"" > |
 < #CHAR: ["\u0000"-"\u0021", "\u0023"-"\uffff"]  >    
}
                         
     

/**
 * for GeoGebra input field
 * validexpression =    
 *                  labellist() = command() |           // e.g. {A,B} = Intersect[c, g]
 *                      <LABEL> : parametric() |        // e.g. X = (3,2) + t (2,1)              
 *                      <LABEL> = expression()      // arithmetic expression of floats, vectors and vars
 *                      <LABEL> : equation()        // equation in x an y
 						<LABEL>(x) = function()   // function in x, e.g. f(x) = 3x^3 - sqrt(x)
 */
ValidExpression buildValidExpression() : 
{
    ValidExpression ve = null;
    ExpressionNode lhs, rhs;
    Token l = new Token();
    Token c = null;
    Vector labels = new Vector();
} 
{         
     (       
        // f(x) =  x^2 + 3	
        LOOKAHEAD(2147483647)
        ve = functionExpressionnode()          
     |             
     	// spreadsheet range like A1:B2
		LOOKAHEAD (3)
		ve = spreadsheetRange()
     |     
        // h: X = (3,2) + t (5,1)
      	LOOKAHEAD(2147483647) 
      	l = label() (":" | <ASSIGNMENT> )  ve = parametric()      
     |     
        // g: 3x + y = 7 
        LOOKAHEAD(2147483647)      
        l = label()  (":" | <ASSIGNMENT> )  ve = equation()        
    |          
        // special case "A: (3,2)" should become a point  
        // CAS assignment "a := 5" should be supported too
        // inequalities "a: 3x + 4y < 7" and intervalls "b: 3 < x < 7" can be named too                                  
	  	LOOKAHEAD(2147483647)  
	    l = label() (":" | <ASSIGNMENT> )  ve = cmdexpression()   
	 |     
        // distingiush <LABEL> = expressionnode()               and  
        //             expressionnode() = expressionnode()      (Equation)
        //
        // equation without label and only one variable on the lhs
        // could be expression too!!!
        // eg. t = 2 x     or     t = 2 s
        
     LOOKAHEAD(2147483647)
        lhs = expressionnode() <EQUAL> rhs = expressionnode()
        {             
            // maybe it's an assignment, i.e. there is no x, y, or z on the right side
			if (!rhs.includesPolynomial())
			{
			    // assignment, e.g. z = 23
	  			if (lhs.isSingleVariable()) {                                  	               
	                ve = rhs;
	                ve.setLabel(((Variable)lhs.evaluate(StringTemplate.defaultTemplate)).getName(StringTemplate.defaultTemplate));                         
	            }
	            
				// special case: e = 2 should be an assignment
				// but an undefined "e" has been read as the Euler constant already
				else if (Unicode.EULER_STRING.equals(lhs.toString(StringTemplate.defaultTemplate)))
				{
				 	ve = rhs;
                  	ve.setLabel("e");  
				}

				// special case: i = 2 should be an assignment
				// but an undefined "i" has been read as the imaginary unit already
				else if (lhs.isImaginaryUnit())
				{
				  	ve = rhs;
                  	ve.setLabel("i"); 
				}
              
				// special case: z = 2 should be an assignment when 3D view is not present
				else if (kernel.isZvarAllowed() && "z".equals(lhs.toString(StringTemplate.defaultTemplate)))
				{
				  ve = rhs;
                  ve.setLabel("z");  
				}
			}
            		
			// standard equation
			if (ve == null) {
                // it's an equation in x, y, and possibly z
                ve = new Equation(kernel, lhs, rhs);
            }            
        }
     |
        LOOKAHEAD(2147483647)
        ve = cmdexpression()     
     |	     
        LOOKAHEAD(2147483647)
        labels = labellist() ("=" | <ASSIGNMENT>) ve = command()    	  	                                       	                       	 	 
   	 |
        LOOKAHEAD(2147483647)                               
	  	ve = cartesianvector_special()
	|
	 	 LOOKAHEAD(2147483647)    
	 	 	ve = polarvector_special()  
    )                     
    ( <EOL> | <EOF> )     
    {                      
        if (labels.size() > 0) ve.addLabel(labels);  // command with ouput labels
        else if (ve.labelCount() == 0) ve.addLabel(l.image);  // standard case                         
        return ve;
    }    
}

/**
 *  parse GeoGebra CAS input
 */
ValidExpression buildCASExpression() : 
{
    ValidExpression ve;
    ExpressionNode lhs, rhs;
    Token l = new Token();
    Token assign = null;
    Token c= null;
    Token c2 =null;
    Vector labels = new Vector();
} 
{         
        // CAS function
       // f(a) := a^2 + 3a
     (        LOOKAHEAD(2147483647)   
        ve = casFunction()
    |	   
       	// labeled equation, e.g. g: 3x + y = 7
       	LOOKAHEAD(2147483647)   
       	l = label() (assign= ":" | assign = <ASSIGNMENT> | assign = <DELAYED_ASSIGNMENT > ) ve = equation()  
    |
        // assignment         
        // b := 27 + c, also allow x := 5, see http://www.geogebra.org/trac/ticket/946
        LOOKAHEAD(2147483647)		
		l = casVar() (assign= ":" |assign = <ASSIGNMENT> | assign = <DELAYED_ASSIGNMENT > ) ve = expressionnode()
 	|	   
       	// equation, e.g. 3x + y = 7
       	LOOKAHEAD(2147483647)   
       	ve = equation()
    | 
    	// expression
    	// 5a + 3    
    	LOOKAHEAD(2147483647)
    	ve = expressionnode()     	     	     
	)                     
    ( <EOL> | <EOF> )     
    {   
    	// remember label      
    	if (l.image != null)
    	{
    	    if(":".equals(assign.image) &&
    	    GeoElementSpreadsheet.isSpreadsheetLabel(ve.toString(StringTemplate.defaultTemplate)))
    	    {
    	      ExpressionNode startCell = new ExpressionNode(kernel, new Variable(kernel, l.image));
		ExpressionNode endCell = new ExpressionNode(kernel, new Variable(kernel, ve.toString(StringTemplate.defaultTemplate)));
		Command cmd = new Command(kernel, "CellRange", false, !ExternalCASParsing ); // don't translate name
		cmd.addArgument(startCell);
		cmd.addArgument(endCell);
		return cmd;
    	    }           
        	ve.addLabel(l.image);
        	ve.setAssignmentType(assign.kind == DELAYED_ASSIGNMENT?AssignmentType.DELAYED:AssignmentType.DEFAULT);
       }                          
        return ve;
    }    
}


/**
 * convert MathPiper String to GeoGebra string
 */
ValidExpression buildMathPiperExpression() : 
{
    ValidExpression ve;
    ExpressionNode lhs, rhs;
    Token l = new Token();
    Vector labels = new Vector();
} 
{         
    (     
		// try to parse MathPiper string as standard GeoGebra expression 
    	ve = buildCASExpression()     	     	   
	)                     
    ( <EOL> | <EOF> )     
    {       	                         
        return ve;
    }    
}

/**
 * convert MPReduce String to GeoGebra string
 */
private ValidExpression buildMPReduceExpression() : 
{
    ValidExpression ve;
    ExpressionNode lhs, rhs;
    Token l = new Token();
    Vector labels = new Vector();
} 
{         
    (     
		// try to parse MPReduce string as standard GeoGebra expression 
    	ve = buildCASExpression()     	     	   
	)                     
    ( <EOL> | <EOF> )     
    {       	                         
        return ve;
    }    
}

/**
 * convert Maxima String to GeoGebra string
 */
ValidExpression buildMaximaExpression() : 
{
    ValidExpression ve;
    ExpressionNode lhs, rhs;
    Token start,sign = null,end;
} 
{         
    (
    	// try to parse Maxima string as standard GeoGebra expression 
    	ve = buildCASExpression() 
	)                     
    ( <EOL> | <EOF> )     
    {       	                         
        return ve;
    }    
}

/**
 * (<VARZ> | <LABEL> | <SPREADSHEET_LABEL>) 
 */
Token label():
{     
    Token t;
}
{         	  
       ( t = <VARZ> | t = <SPREADSHEET_LABEL> |  t = <LABEL> )
        {  return t;   }
}

/**
 * (<VARX> | <VARY> | <VARZ> | <LABEL> | <SPREADSHEET_LABEL>) 
 */
Token casVar():
{
  Token t;
}
{
	(t = <VARX> | t = <VARY> | t = <VARZ> | t = <LABEL> | t = <SPREADSHEET_LABEL>)
	{
	  return t;
	}
}


/**
 * command =     <LABEL> [ argument (, argument)* ]  
 */
ValidExpression command():
{     
    Command c;
    Token t;
    String cmdName;
    ExpressionNode en;
}
{   
	(
     	(t = <FUNCTION_LABEL>) // includes (
	    { cmdName = t.image.substring(0,t.image.length()-1);
	      c = new Command(kernel, cmdName, true, !ExternalCASParsing );    } 
	    (   ( en = cmdexpression()  { c.addArgument( en ); } )?
	        ( <COMMA> en = cmdexpression() { c.addArgument( en ); } )*
	    (")"|"]") )
	    { if(MPReduceParsing)
	    {
	      ExpressionNode res = CommandDispatcherMPReduce.processCommand(cmdName,c);
	      if(res!=null)
	      	return res;
	    }
	    return c; }
	)
}

/**
 * labellist =    { <LABEL> (, <LABEL>)* }  
 */
Vector labellist():
{         
    Token t;    
    Vector labels;
}
{
(( 
    "{" (t=label()) 
        {   
            labels = new Vector(); labels.add(t.image);  
        }
     ( <COMMA> (t=label())   { labels.add(t.image); } )*
    "}" 
)
    |    
( 
    (t=label())   
        {   
            labels = new Vector(); labels.add(t.image);  
        }
     ( <COMMA> (t=label())   { labels.add(t.image); } )*
))
     { return labels; }
}


/**
 * parametric =   <PARAMETRICVAR> = vector + <LABEL> * vector  |
 *                <PARAMETRICVAR> = vector - <LABEL> * vector |
 */
Parametric parametric():
{         
    ExpressionValue P, v;
    ExpressionValue temp;
    Token s, par;    
}
{    
    <LABEL> <EQUAL> P = multterm()
    ( 
     (s = <PLUS> | s = <MINUS>) par = <LABEL> (<MULTIPLY>)? v = expression()
         {                                    
            if (s.kind == MINUS) 
                v = new ExpressionNode(kernel, new MyDouble(kernel, -1.0d), Operation.MULTIPLY, v);                    
            return new Parametric(kernel, P, v, par.image );                
         }
    ) 
}


/** NOT USED BY NOW
 * normalvectorform =   <PARAMETRICVAR> vector  = vector 
 
NormalVectorForm normalvectorform():
{         
    ExpressionNode left, right;
    ExpressionValue temp;
}
{    
    <PARAMETRICVAR> (<MULTIPLY>)? left = enterm()  <EQUAL> right = expressionnode()           
         {                        
            // check if left is VectorValue and right is NumberValue
            temp = left.evaluate();
            if (!(temp instanceof VectorValue)) {
                String [] str = { "VectorExpected", temp.toString() };
                throw new MyParseError(loc, str);
            }

            temp = right.evaluate();
            if (!(temp instanceof NumberValue)) {
                String [] str = { "NumberExpected", temp.toString() };
                throw new MyParseError(loc, str);
            }        
            
            return new NormalVectorForm( left, right );                
         }   
}
*/

/******************************************************************
 * ARTIHMETIC FOR NUMBERS AND 2D VECTORS WITH VARIABLES
 * plus
 * ARTIHMETIC FOR POLYNOMIALS WITH VARIABLES "x" AND "y"
 * exponents must be integers >= 0
 * divisors must be simplifyable to numbers
 ******************************************************************/


/**
 * equation =       expression = expression
 */
Equation equation():
{
    ExpressionNode lhs, rhs;
}
{    
    lhs = expressionnode() <EQUAL> rhs = expressionnode()
        {             
            return new Equation(kernel, lhs, rhs); 
        }
}




/**
 * expression = expressionnode
 */
ExpressionNode expression():
{
    ExpressionNode rhs;
}
{    
    rhs = expressionnode()              
    {
        if (!GeoGebraCASParsing && rhs.includesPolynomial()) {
        	throw new MyError(loc, "IncompleteEquation");
        }
        
        // since v3.0: commands have to take care of resolving the variables of 
        // their arguments on their own, e.g. Sequence[ (i, i^2), i , 1, 10 ]       
		//rhs.resolveVariables();
        return rhs;
    }
}

/**
 * cmdexpression = expressionnode 
 * (may only return Function)
 */
ExpressionNode cmdexpression():
{
    ExpressionNode en;
}
{

   en = expressionOrEquation()              
    {
        

 	
       if (!GeoGebraCASParsing && !(en.unwrap() instanceof Equation)) {
          	en = polysToFunctionVariables(en);
        	//throw new MyError(app, "IncompleteEquation");
        }
        
       
        
        // since v3.0: commands have to take care of resolving the variables of 
        // their arguments on their own, e.g. Sequence[ (i, i^2), i , 1, 10 ]       
		//rhs.resolveVariables();
        return en;
    }
}


/**
 * function = functionExpressionnode 
 */
Function  function():
{
    ExpressionNode rhs;
    Token l = null;
    Function f;
}
{          
(
	   // f(x) =  x^2 + 3	
	 	 rhs = functionExpressionnode()
	    {
	    	if (rhs.getLeft() instanceof Function) {
	    		f = (Function) rhs.getLeft();
	    	}
	    	else {
		        f = new Function(rhs);		        
		    }
		    f.setLabel(rhs.getLabel());	       
		    return f;
	    }   
)	   
}

/**
 * functionNVar = functionExpressionnode 
 */
FunctionNVar  functionNVar():
{
    ExpressionNode rhs;
    Token l = null;
    FunctionNVar f;
}
{          
(
	   // f(x) =  x^2 + 3	
	 	 rhs = functionExpressionnode()
	    {
	    	if (rhs.getLeft() instanceof FunctionNVar) {
	    		f = (FunctionNVar) rhs.getLeft();
	    	}
	    	else {
		        f = new FunctionNVar(rhs);		        
		    }
		    f.setLabel(rhs.getLabel());	       
		    return f;
	    }   
)	   
}

/**
 * function = 	f(var1, var2) = expressionnode 
 *				f(var) := expressionnode 
 *				f(var) = command
 */
ExpressionNode functionExpressionnode():
{
    ExpressionNode rhs;
    Token funName = null;
    Token varName = null;
    ArrayList<String> localVars;
    Token var;
}
{          
(
  		// single or multi-variable function definition
	   // f(a) =  a^2 + 3
	   // g(x,y) := x * y
	   (
	     funName = <FUNCTION_LABEL> |  // includes "(" at end
	     funName = <Z_FUNC> // includes "(" at end
	   ) 
	   		// local variables, allow function of y and deal with it in GeoFunction constructor
	   		(( varName =  <VARX> | varName =  <VARY> | varName = label() )
	   		  { localVars = new ArrayList<String>(); localVars.add(varName.image);
	   		  kernel.getConstruction().registerFunctionVariable(varName.image);} )
			// optional second variable			
			 (<COMMA> ( varName = casVar() )
			 { localVars.add(varName.image);
			 kernel.getConstruction().registerFunctionVariable(varName.image);} )* 
			// closing ) and assignment with expressionnode
	   		 ")" ( <EQUAL > | <ASSIGNMENT> ) rhs = expressionnode()
	    {
	      	// allow f(y) in CAS but not in GeoGebra
		//	if (!ExternalCASParsing && !GeoGebraCASParsing && "y".equals(varName.image)) 
	    //    	throw new MyError(app, "InvalidInput");
	    
		  	String funLabel = funName.image.substring(0,funName.image.length()-1);	 

			// command without variables: return expressionnode
	    	if (rhs.getLeft() instanceof Command && !rhs.includesPolynomial()) {
				rhs.setLabel(funLabel);
				return rhs;
			}

	    	// function: wrap function in ExpressionNode
			// number of vars
			int n = localVars.size();
			
			FunctionVariable[] funVar = new FunctionVariable[n];
	    	for (int i=0;i<n; i++){
	    		funVar[i] = new FunctionVariable(kernel);
	    		funVar[i].setVarString(localVars.get(i));
	    	}

    	    switch (n) {
    	      case 1: // single variable function					
				Function fun = new Function(rhs, funVar[0]);
				fun.setLabel(funLabel);
				rhs = new ExpressionNode(kernel, fun);
				break;

       		  default: // multi variable function
       			FunctionNVar funn = new FunctionNVar(rhs, funVar);
				funn.setLabel(funLabel);
				rhs = new ExpressionNode(kernel, funn);
       			break;
    	    }    			   
       		
       		rhs.setLabel(funLabel);
       		return rhs;
	    }   
)
}

/**
 * CAS function = 	label(var) := expressionnode 
 */
FunctionNVar casFunction():          
{
    ExpressionNode rhs;
    Token funName = null;
    Token varName = null;
    Token assign = null;
    ArrayList<String> localVars;
    Token var;
}
{          
(
  		// single or multi-variable function definition
	   // f(a) =  a^2 + 3
	   // g(x,y) := x * y
	   (
	     funName = <FUNCTION_LABEL> |  // includes "(" at end
	     funName = <Z_FUNC> // includes "(" at end
	   )    
	   		// local variables
	   		(( varName =  casVar() )
	   		  { localVars = new ArrayList<String>(); localVars.add(varName.image); } )
			// optional second variable			
			 (<COMMA> ( varName =  casVar() )
			 { localVars.add(varName.image); } )* 
			// closing ) and assignment with expressionnode
	   		 ")" (assign = <ASSIGNMENT> | assign = < DELAYED_ASSIGNMENT >) rhs = expressionnode()
	    {
		  	String funLabel = funName.image.substring(0,funName.image.length()-1);	 

			// number of vars
			int n = localVars.size();
			
			FunctionVariable[] funVar = new FunctionVariable[n];
	    	for (int i=0;i<n; i++){
	    		funVar[i] = new FunctionVariable(kernel);
	    		funVar[i].setVarString(localVars.get(i));
	    	}

    	    switch (n) {
    	      case 1: // single variable function					
				Function fun = new Function(rhs, funVar[0]);
				fun.setLabel(funLabel);
				fun.setAssignmentType(assign.kind == DELAYED_ASSIGNMENT?AssignmentType.DELAYED:AssignmentType.DEFAULT);
				return fun;

       		  default: // multi variable function
       			FunctionNVar funn = new FunctionNVar(rhs, funVar);
				funn.setLabel(funLabel);
				funn.setAssignmentType(assign.kind == DELAYED_ASSIGNMENT?AssignmentType.DELAYED:AssignmentType.DEFAULT);
				return funn;
    	    }
	    }   
)	 
}     


/**
 *  expression =  term <OR> term
 */
ExpressionNode expressionnode():
{
    ExpressionValue ret, f;
    Token x;
}
{
    ret = ORterm()                 
    ( <IMPLICATION>  f = ORterm()
        {                
	         ret = new ExpressionNode(kernel, ret, Operation.IMPLICATION, f);                   
        }
    )*
    { 
    	ExpressionNode en;
    	if (ret.isExpressionNode())
    		en = (ExpressionNode) ret;
    	else
    		en = new ExpressionNode(kernel, ret);
    	
    	//en.expandEquationExpressions();
    	if (ExternalCASParsing)
    		en.simplifyLeafs();
    	return en; 
    }
}

/**
 *  expressionOrEquation =  equation | expressionnode 
 */
ExpressionNode expressionOrEquation():
{
    ExpressionNode en, rhs;
}
{ 
 		en = expressionnode()
    	(  <EQUAL> rhs = expressionnode()
	        {             
	            en = new ExpressionNode(kernel, new Equation(kernel, en, rhs)); 
	        }    
    	)?
	{                
		return en;             
	}
}

/**
 * ANDterm =   COMPAREterm <AND> COMPAREterm 
 */
ExpressionValue ANDterm():
{
    ExpressionValue ret, f;
    Token x;    
}
{
    ret = COMPAREterm()           
    ( <AND>  f = COMPAREterm() 
        {
        	ret = new ExpressionNode(kernel, ret, Operation.AND, f);             
        }     
    )*
    { return ret; }  
}

/**
 * ORterm =   ANDterm <OR> ANDterm 
 */
ExpressionValue ORterm():
{
    ExpressionValue ret, f;
    Token x;    
}
{
    ret = ANDterm()           
    ( <OR>  f = ANDterm() 
        {
        	ret = new ExpressionNode(kernel, ret, Operation.OR, f);             
        }     
    )*
    { return ret; }  
}

/**
 * COMPAREterm =   listopnode ("==" | "<" | "<=" | ">" | ">=") listopnode 
 */
ExpressionValue COMPAREterm():
{
    ExpressionValue left, right;
    ExpressionNode result;   
    Vector<ExpressionNode> andList = null; // support multiple comparisons like 3 < x < 7
}
{
    left = listopnode()  
    (         
       (
         (<EQUAL_BOOLEAN>  right = listopnode()
    	 {            
    	   if (ExternalCASParsing)
    	       result = new ExpressionNode(kernel, new Equation(kernel, left, right));
    	   else
           	   result = new ExpressionNode(kernel, left, Operation.EQUAL_BOOLEAN, right);  
         }
       )   
     |   
       (<NOT_EQUAL>  right = listopnode()
    	 {            
           result = new ExpressionNode(kernel, left, Operation.NOT_EQUAL, right);  
         }
       )   
     |  
       (<IS_SUBSET_OF>  right = listopnode()
    	 {            
           result = new ExpressionNode(kernel, left, Operation.IS_SUBSET_OF, right);  
         }
       )   
     |   
       (<IS_SUBSET_OF_STRICT>  right = listopnode()
    	 {            
           result = new ExpressionNode(kernel, left, Operation.IS_SUBSET_OF_STRICT, right);  
         }
       )   
     |   
       (<LESS>  right = listopnode()
    	 {            
           result = new ExpressionNode(kernel, left, Operation.LESS, right);  
         }
       ) 
     |
       (<GREATER>  right = listopnode()
    	 {            
           result = new ExpressionNode(kernel, left, Operation.GREATER, right);  
         }
       ) 
     |
       (<LESS_EQUAL>  right = listopnode()
    	 {            
           result = new ExpressionNode(kernel, left, Operation.LESS_EQUAL, right);  
         }
       ) 
     |
       (<GREATER_EQUAL>  right = listopnode()
    	 {            
           result = new ExpressionNode(kernel, left, Operation.GREATER_EQUAL, right);  
         }
       ) 
      |
   	    (<PARALLEL>  right = listopnode()
    	 {            
           result = new ExpressionNode(kernel, left, Operation.PARALLEL, right);  
         }
         ) 
      |
   	    (<PERPENDICULAR>  right = listopnode()
    	 {            
           result = new ExpressionNode(kernel, left, Operation.PERPENDICULAR, right);  
         }
        )
     )                    
     {
        // store all AND parts
        // e.g. 3 < x < 7 should get stored as 3 < x && x < 7
      	if (andList == null)
			andList = new Vector<ExpressionNode>();
		andList.add(result);
		left = right;
     }
    )* 
    {
      if (andList != null) {
  		// build AND ExpressionNode tree, e.g. 3 < x && x < 7
        left = andList.get(0);
        for (int i=1; i < andList.size(); i++) {
			left = new ExpressionNode(kernel, left, Operation.AND_INTERVAL, andList.get(i));
        }   
      }
      return left;
    }  
}

/**
 *  expression =    term + term |
 *                  term - term
 */
ExpressionValue plusminusnode():
{
    ExpressionValue ret, f;
    Token x;
}
{
    ret = multterm()                 
    (( x = <PLUS> | x = <MINUS> ) f = multterm()
        {                       
            if (x.kind == PLUS) 
                ret = new ExpressionNode(kernel, ret, Operation.PLUS, f);  
            else
                ret = new ExpressionNode(kernel, ret, Operation.MINUS, f);  
        }
    )*
    { 
    	//ret.simplifyLeafs();
    	return ret; 
    }
}

ExpressionValue setdifferencenode():
{
    ExpressionValue ret, f;
    Token x;
}
{
    ret = plusminusnode()                 
    (<SET_DIFFERENCE> f = plusminusnode()
        {                       
            ret = new ExpressionNode(kernel, ret, Operation.SET_DIFFERENCE, f);  
        }
    )*
    { 
    	//ret.simplifyLeafs();
    	return ret; 
    }
}

ExpressionValue listopnode():
{
    ExpressionValue ret, f;
    Token x;
}
{
    ret = setdifferencenode()                 
    (<IS_ELEMENT_OF> f = setdifferencenode()
        {                       
            ret = new ExpressionNode(kernel, ret, Operation.IS_ELEMENT_OF, f);  
        }
    )?
    { 
    	//ret.simplifyLeafs();
    	return ret; 
    }
}

/**
 * multterm =   divterm * divterm 
 */
ExpressionValue multterm():
{
    ExpressionValue ret, f;
    Token x;    
}
{
    ret = divterm()           
    (                 
     ( x = <MULTIPLY> | x = <VECTORPRODUCT> ) f = divterm() 
        {
            if (x.kind == MULTIPLY) {
                ret = new ExpressionNode(kernel, ret, Operation.MULTIPLY, f);   
            } else {
                ret = new ExpressionNode(kernel, ret, Operation.VECTORPRODUCT, f);  
            }
        }
     |
     f = powerdivterm()
        { 
               ret = new ExpressionNode(kernel, ret, Operation.MULTIPLY, f);  
         }	
    )*
    { return ret; }  
}

/**
 * divterm =  unary / unary
 */
ExpressionValue divterm():
{
    ExpressionValue ret, f;
    Token x;    
}
{
    ret = enunary()           
    (                 
       <DIVIDE> f = enunary() 
        {
            ret = new ExpressionNode(kernel, ret, Operation.DIVIDE, f); 
        }	
    )*
    { return ret; }  
}

/**
 * powerdivterm =  power / unary
 */
ExpressionValue powerdivterm():
{
    ExpressionValue ret, f;
    Token x;    
}
{
    ret = enpower()           
    (                 
       <DIVIDE> f = enunary() 
        {
            ret = new ExpressionNode(kernel, ret, Operation.DIVIDE, f); 
        }	
    )*
    { return ret; }  
}

/**
 * unary =  -power    |
 * 	        +power    | 	
 *          power
 */
ExpressionValue enunary():        
{
    ExpressionValue e;
    Token c;
}
{
    <MINUS> e = enpower()
        { // -e  = -1*e
          return new ExpressionNode(kernel, new MyDouble(kernel, -1.0d), Operation.MULTIPLY, e);              
        }
|
   <PLUS> e = enpower()
        { // +e  = e
          return e;              
        }
|
    e = enpower()
        {
            return e;
        }
}

/**
 * power =    element                 |
 *          element ^ power           
 */
ExpressionValue enpower():
{
    ExpressionValue ret, f;
    Token c = null;
    ArrayList<ExpressionValue> exponentList = null;
    
}
{	
    ret = enfactorial()         
    (
      	(   
    	 c = <POWERN> 
        {            
            f = new MyDouble(kernel, c.image);
            // collect exponents
			if (exponentList == null)
				exponentList = new ArrayList<ExpressionValue>();
            exponentList.add(f);  
	    }
	 	)     
    |                   
    	(
    	  	<POWER> (c = <MINUS> | c = <PLUS>)? f = enfactorial()
        {
          	// -f  = -1*f
			if (c != null && c.kind == MINUS)
			{			  				
         		f = new ExpressionNode(kernel, new MyDouble(kernel, -1.0d), Operation.MULTIPLY, f);
         		c = null; // make sure we forget minus for next exponent
            }
        	
			// collect exponents
			if (exponentList == null)
				exponentList = new ArrayList<ExpressionValue>();
            exponentList.add(f);  

           /*
        	// check if we have e^
        	if (ret.isExpressionNode()) {
        		ExpressionNode en = (ExpressionNode) ret;
	        	if (en.isLeaf() &&  en.getLeft() instanceof MyDouble) {
	        		MyDouble num = (MyDouble) en.getLeft();
	        		if (num.getDouble() == Math.E) {      	
	        	    	ret = new ExpressionNode(kernel, f, Operation.EXP, null);        		
	        		} 
	        	}       
        	}
			*/			         	                           
        }
        )                       
    )*
    {
		if (exponentList == null)
			return ret;
      
      	if (MPReduceParsing)
      	{      	 
	        // MPReduce: left associative: a^b^c = (a^b)^c
			for (int i=0; i< exponentList.size(); i++)
			{
				ExpressionValue exponent = exponentList.get(i);
				ret = makePower(ret, exponent);
			}
		}
		else
		{
      		// GeoGebra: right associative: a^b^c = a^(b^c)
      		int size = exponentList.size();
      		ExpressionValue tempEV = exponentList.get(size-1); // last exponent, e.g. c
      		for (int i=size-2; i >= 0; i--)
			{
				ExpressionValue prevExponent = exponentList.get(i);
				tempEV = makePower(prevExponent,tempEV);
			}
			ret = makePower(ret, tempEV);
		}
  
      	return ret;

      }    
}

/**
 * factorial =  <NOTterm> |
 *              <NOTterm> !
 */
ExpressionValue enfactorial():
{   
    ExpressionValue en;   
}
{     
	    en = ensqrt() 
	    (LOOKAHEAD(<FACTORIAL>) <FACTORIAL> 
	     {
	       		if(en.isExpressionNode() && ((ExpressionNode)en).getOperation()==Operation.MULTIPLY_OR_FUNCTION)
	       		{
	       		  en = new ExpressionNode(kernel, ((ExpressionNode)en).getLeft(),
	       		  	Operation.MULTIPLY,
	       		  	new ExpressionNode(kernel, ((ExpressionNode)en).getRight(), Operation.FACTORIAL, null)
	       		  	);
	       		}
	       		else
	            en = new ExpressionNode(kernel, en, Operation.FACTORIAL, null);                    
	     }      
	     )?    
	     { return en; }	    	
}

ExpressionValue ensqrt():
{   
    ExpressionValue en;   
}
{     
	    <SQRT_SHORT > en = NOTterm()  
	     {
	       		if(en.isExpressionNode() && ((ExpressionNode)en).getOperation()==Operation.MULTIPLY_OR_FUNCTION)
	       		{
	       		  en = new ExpressionNode(kernel,
	       		  new ExpressionNode(kernel, ((ExpressionNode)en).getLeft(), Operation.SQRT_SHORT, null),
	       		  	Operation.MULTIPLY,
	       		  ((ExpressionNode)en).getRight()	
	       		  	);
	       		}
	       		else
	            en = new ExpressionNode(kernel, en, Operation.SQRT_SHORT, null);
	            return en;               
	     }     | en = NOTterm() 
	         
	     { return en; }
	     { return en; }	
}

/**
 * NOTterm =  <NOT> <enelement> |
 *               	<enelement>
 */
ExpressionValue NOTterm():
{   
    ExpressionValue en;   
}
{     
	(
	    ( <NOT> | "!" ) en = enelement() 	    
	     {            
	            return new ExpressionNode(kernel, en, Operation.NOT, null);       
	     }      
	 ) 
|
	 (
	  	en = enelement() 	
	     { return en; }	    	
	 )	    	     
}

/**
 * element =    <variable>      |
 *              <float>         |
 *              ( expression )
 */
ExpressionValue enelement():
{    
    ExpressionValue ev;
    double num;
    Token c;    
}
{   
// boolean
	<TRUE>
	 { return  new MyBoolean(kernel, true); }     
|
	<FALSE>
	  { return new MyBoolean(kernel, false); }     
|	 	 
 // number
    ev = myDouble()
        { return ev; }      
|
    // cos, sin, tan, ...
    LOOKAHEAD(2147483647)
    ev = numberFunction()
         { return ev; }
|
	// command
	LOOKAHEAD(2147483647)
    ev = command()
        { return ev; } 
|
    // number or vector variable
     LOOKAHEAD(2147483647)
    ev = numVecVariable()
        { return ev; }
|        
    //list
    LOOKAHEAD(2147483647)
	ev = list()
	    { return ev; }      
| 
    // parenthesis
    LOOKAHEAD(2147483647)
    "("  ev = expressionOrEquation()  ")" 
        { return  ev.unwrap(); }       	           
|
    // cartesian vector  (x, y) or (x|y)
    LOOKAHEAD(2147483647)
    ev = cartesianvector()
        { return ev; } 
|    
    // cartesian vector  (x, y, z) or (x|y|z)
    LOOKAHEAD(2147483647)
    ev = cartesianvector3D()
        { return ev; } 
|    
    // polar vector   
    LOOKAHEAD(2147483647)
    ev = polarvector()
        { return ev; } 
 |
	// text (between " ... ")
	c = <TEXT>
    { 
    	// remove " (first and last character)
    	String text = c.image.substring(1, c.image.length()-1);
    	return  new MyStringBuffer(kernel, text);
     }  
}

ExpressionValue list():
{
    MyList myList;
    ExpressionValue ev;
}
{
   LOOKAHEAD(5)
   (
     // empty list
      "{" "}"  
      {   
           return new MyList(kernel);               
       }
    )
    |
   ( 
    // list
    "{"
      ev = cmdexpression()     
       {   
            myList = new MyList(kernel);         
            myList.addListElement(ev);
        }
       ( <COMMA> ev = cmdexpression()  
       	 {
       		myList.addListElement(ev); 
       	 } 
        )*
    "}"
    {  return myList;  }
   )
|
	// matrix from MPReduce,e.g. mat((1,2),(3,4))
    ev = matrixReduce()
    {
        return ev;
    }   
}

// mat((1,2),(3,4)) from MPReduce
ExpressionValue matrixReduce():
{
    MyList matrixList, rowList;
    ExpressionValue row;
}
{
    // matrix from MPReduce
    < MAT_FUNC >
      // first row
      row = matrixRowReduce()
      	{
      	  	matrixList = new MyList(kernel);
      	  	matrixList.addListElement(row);
      	 }  	     
     ( <COMMA> row = matrixRowReduce()  
   	  	{
   			matrixList.addListElement(row); 
   	  	} 
      )*	     
    ")" // end of mat(...)
    {  return matrixList;  }             
}

// (a,b,c)
ExpressionValue matrixRowReduce():
{
    MyList  rowList;
    ExpressionValue ev;
}
{
      // row like (1,2,3)
      "("
	      ev = cmdexpression()     
	       {   
	            rowList = new MyList(kernel);         
	            rowList.addListElement(ev);
	        }
	       ( <COMMA> ev = cmdexpression()  
	       	 {
	       		rowList.addListElement(ev); 
	       	 } 
	        )*
	   ")"
	    {  return rowList;  }  	            
}  

ExpressionValue numVecVariable():
{
    GeoElement geo;
    Token c;
    ExpressionValue ev;
}
{
    c = <VARX>  
    {
      
        if (GeoGebraCASParsing)
 			return new Variable(kernel, c.image);
		else		
        	return new Polynomial(kernel, c.image);
    }
|
    c = <VARY>  
    {
        if (GeoGebraCASParsing)
 			return new Variable(kernel, c.image);
		else
        	return new Polynomial(kernel, c.image);
    }
|
    c = <VARZ>  
    {
        // check for CAS parsing or if z is defined in kernel
        if (GeoGebraCASParsing || kernel.lookupLabel("z") != null) {
 			return new Variable(kernel, c.image);
		} else {
	 		// z is not defined: treat as equation variable for 3D view
    		return new Polynomial(kernel, c.image);
       }
    }
|
	// spreadsheet range like A1:B2
	LOOKAHEAD (3)
	ev = spreadsheetRange()
	{
		return ev;
	}
|
    ( c = <SPREADSHEET_LABEL> | c = <LABEL> )
    {
        // should we read e for Euler constant and i for imaginary unit?
		boolean lookforEulerImaginary = false;

		if (GeoGebraCASParsing)
		{
		  	// leave e and i untouched in GeoGebraCAS view
		  	lookforEulerImaginary = false;
		}
		else if (ExternalCASParsing)
		{	// MPReduce uses e and i for Euler and imaginary constants
		  	lookforEulerImaginary = MPReduceParsing;
		}
		else
		{ 	// GeoGebraCAS or GeoGebra parsing
			// only treat e or i specially when they are undefined in GeoGebra
			lookforEulerImaginary = kernel.lookupLabel(c.image) == null;
		}
    	
        // return defined variables immediately
		if (lookforEulerImaginary)
		{
			// TREAT e and i specially
			// e for Euler constant
			if (c.image.equals("e"))
			{		 
				return MySpecialDouble.getEulerConstant(kernel);
			}
			// i for imaginary unit
			else if (c.image.equals("i"))
			{
			  	return kernel.getImaginaryUnit();
			}
		}      				

       // standard case for variables
       return new Variable(kernel, c.image);
    }
}


/**
 * spreadsheet range, e.g. A3:B5
 */
Command spreadsheetRange():
{
    Token c, c2;
}
{
	// spreadsheet range like A1:B2
	c = <SPREADSHEET_LABEL> ":" c2 = <SPREADSHEET_LABEL>
	{
		// build command CellRange[ startCell, endCell ]
		ExpressionNode startCell = new ExpressionNode(kernel, new Variable(kernel, c.image));
		ExpressionNode endCell = new ExpressionNode(kernel, new Variable(kernel, c2.image));
		Command cmd = new Command(kernel, "CellRange", false, !ExternalCASParsing ); // don't translate name
		cmd.addArgument(startCell);
		cmd.addArgument(endCell);
		return cmd;
	}
}
   

/**
 * floating point number: angle or numeric are distinguished
 */
ExpressionValue myDouble():
{
    Token c;
    MyDouble d;
    double val;
}
{       
   (
     (c = <FLOAT> | c = <EFLOAT>)
    	{
			// check if token includes "b"
    	  
    	    c.image = c.image.replaceFirst("e", "E" );
    		val = MyDouble.parseDouble( loc, c.image );
    	}
    |
      (c = <PERCENTAGE>) 
  		{
    		val = MyDouble.parsePercentage( loc, c.image );
    	}
   )
  {
    	if (ExternalCASParsing || GeoGebraCASParsing) {
    		// preserve string from CAS: it may have higher
    		// precision than double
    	   	return new MySpecialDouble(kernel, val, c.image);  
    	}
    	else {
      	  return new MyDouble(kernel, val);
    	}                               
    }
|
    <DEGREE>
    {  // constant for degree to radians 
        d = new MySpecialDouble(kernel, Math.PI / 180.0d, "\u00b0");
        d.setAngle();
        return d;
    }
|
    <RAD>
    {  // constant for radians to radians 
        d = new MySpecialDouble(kernel, 1.0d, "rad");
        d.setAngle();
        return d;
    }
|
    <PI>
    {
       	return new MySpecialDouble(kernel, Math.PI, Unicode.PI_STRING);
    }
|
    <E>
    {
    	return new MySpecialDouble(kernel, Math.E, Unicode.EULER_STRING);
    }
|
 	<IMAGINARY>
    {
    	GeoVec2D z = new GeoVec2D(kernel, 0, 1);
    	z.setMode(Kernel.COORD_COMPLEX);
    	return z;
    }    	   
 |
    <INFINITY>
    {
        return new MyDouble(kernel, Double.POSITIVE_INFINITY);
    }   
|
    <MINUS_INFINITY>
    {
        return new MyDouble(kernel, Double.NEGATIVE_INFINITY);
    }   
|
	<UNDEFINED>
	{
        return new MyDouble(kernel, Double.NaN);
    }
}


/**
 * mathematical Function (cos, sin, tan, ...)
 */
ExpressionNode numberFunction():
{
    ExpressionNode en, en2, en3,en4;
    ExpressionValue ev;
    MyList myList;
    Token c, flabel, fvar1, fvar2;
    String conslabel;
    MySpecialDouble myconst;
}
{           
    c = <X_FUNC> en = expressionOrEquation() (")"|"]")
      {
        if (GeoGebraCASParsing) 
        {
          	// GeoGebra CAS view: x(...) is interpreted as a function
          	String funName = c.image.substring(0,c.image.length()-1);
          	Command cmd = new Command(kernel, funName, true, !ExternalCASParsing );
			cmd.addArgument( en );			
			return new ExpressionNode(kernel, cmd);
      	}
      	else
      	{
      	  // standard GeoGebra input bar: x(...) is interpreted as "x-coordinate of"
      	  return new ExpressionNode(kernel, en, Operation.XCOORD, null);
      	}
       }  
|
     c = <Y_FUNC> en = expressionOrEquation() (")"|"]")
      {
        if (GeoGebraCASParsing) 
        {
          	// GeoGebra CAS view: y(...) is interpreted as a function
          	String funName = c.image.substring(0,c.image.length()-1);
          	Command cmd = new Command(kernel, funName, true );
			cmd.addArgument( en );			
			return new ExpressionNode(kernel, cmd);
      	}
      	else
      	{
      	  // standard GeoGebra input bar: y(...) is interpreted as "y-coordinate of"
      	  return new ExpressionNode(kernel, en, Operation.YCOORD, null);
      	}
       } 
|
     c = <Z_FUNC> en = expressionOrEquation() (")"|"]")
     {
        if (GeoGebraCASParsing) 
        {
          	// GeoGebra CAS view: z(...) is interpreted as a function
          	String funName = c.image.substring(0,c.image.length()-1);
          	Command cmd = new Command(kernel, funName, true, !ExternalCASParsing );
			cmd.addArgument( en );			
			return new ExpressionNode(kernel, cmd);
      	}
      	else
      	{
      	 	 // standard GeoGebra input bar: z(...) is interpreted as user function z or "z-coordinate of"
      	   	 GeoElement userFun = kernel.lookupLabel("z");
			 if (userFun instanceof Evaluatable) {
			    // user defined function z
				return new ExpressionNode(kernel, userFun, Operation.FUNCTION, en);
	       	 } else {
				 // internal function z
				return new ExpressionNode(kernel, en, Operation.ZCOORD, null);
	         }
      	}
      }
| 
	    ( c = <FUNCTION_POWER_LABEL> ) en = expressionOrEquation() (")"|"]") 
	 	      {
	 	        int pos = c.image.length()-2;
	 	        while(pos >=0 && (Unicode.isSuperscriptDigit(c.image.charAt(pos))||
	 	        Unicode.Superscript_Minus==c.image.charAt(pos))){
	 	          pos--;
	 	        }
	 	        ExpressionNode ret = kernel.handleTrigPower(c.image, en, c.image.substring(0,pos+1));
	 	        if(ret.getOperation()==Operation.MULTIPLY_OR_FUNCTION)
	 	        	undecided.add(ret);
	 	        return ret;
	 	        }          
|      <RANDOM_FUNC>
      {  
      	 Construction cons = kernel.getConstruction();
      	 GeoNumeric randNum = new GeoNumeric(cons);
         cons.addRandomGeo(randNum);
         randNum.setValue(app.getRandomNumber());         
      	 return new ExpressionNode(kernel, randNum, Operation.RANDOM, null);
      }
|
	(
	  c = <FUNCTION_LABEL> en = expressionOrEquation()
		{   
            myList = new MyList(kernel, true);         
            myList.addListElement(en);
        }
       ( <COMMA> en = expressionOrEquation()  
       	 {
       		myList.addListElement(en); 
       	 } 
        )*
    )
	(")"|"]")
	// note: the last character of FUNCTION_LABEL is a "("
      { 
      		// remove the opening parenthesis
      		String funcName = c.image.substring(0, c.image.length()-1);			
			
			if (MPReduceParsing)  {
			  	// check for special MPReduce functions, e.g. df, arbconst, etc.
				en = CommandDispatcherMPReduce.processCommand(funcName, myList);
				if (en != null)
					return en;
		    }

			boolean forceCommand = c.image.charAt(c.image.length()-1)=='[';
			GeoElement geo = null;    
      		GeoElement cell = null;
			// check for derivative using f'' notation
      		int order = 0;
      		int index = funcName.length()-1;
			String label = funcName;
			if(!forceCommand){
      		
	      		geo = kernel.lookupLabel(funcName);    
	      		cell = kernel.lookupCasCellLabel(funcName);
				
	      		if (cell==null && (geo == null || !(geo.isGeoFunction() || geo.isGeoCurveCartesian())))	{	      		    while (index >=0 && c.image.charAt(index) == '\''){	      		      	order++; 
	      		    	index--;
	      		   }
	      			    	
		      		while (index < funcName.length()) {
		      			label = funcName.substring(0, index+1);
		      			geo = kernel.lookupLabel(label);
		      			cell = kernel.lookupCasCellLabel(label);	      			
		      			// stop if f' is defined but f is not defined, see #1444
		      			if (cell!=null ||
		      			(geo != null && (geo.isGeoFunction() || geo.isGeoCurveCartesian()))) {		      					break;
		      			}
		      				
		      			order--;
		      			index++;
		      		}
		      	}
	      		
	      		//f(t)=t(t+1)
	      		if(kernel.getConstruction().isRegistredFunctionVariable(funcName)){
	      		  ExpressionNode expr =  new ExpressionNode(kernel, new Variable(kernel,funcName), Operation.MULTIPLY_OR_FUNCTION, myList.getListElement(0));
		      		undecided.add(expr);
		      		return expr; 
	      		}

        }
      		  
      		if (forceCommand || (geo == null && cell==null)) {
      		  		Operation op = app.getParserFunctions().get(funcName,myList.size());
      		  		if(op!=null)
      		  			return buildOpNode(op,myList);
      				// function name does not exist: return command
      				Command cmd = new Command(kernel, funcName, true, !ExternalCASParsing );
      				for (int i=0; i < myList.size(); i++)
      				{
      				  cmd.addArgument(GeoGebraCASParsing ? (ExpressionNode) myList.getListElement(i) :
      				  polysToFunctionVariables((ExpressionNode) myList.getListElement(i)));
      				}
      				return new ExpressionNode(kernel, cmd);      						
      			
//      		  	String [] str = { "UndefinedVariable", funcName };
//           	 	throw new MyParseError(loc, str);    
           	}
           	//make sure we don't send 0th derivative to CAS
			if(cell!=null && order > 0)	{
			  
           	ExpressionNode derivative =  new ExpressionNode(kernel, cell, Operation.DERIVATIVE, 
	      																new MyDouble(kernel, order));
      			
	      		return new ExpressionNode(kernel, derivative, Operation.FUNCTION, myList.getListElement(0)); 
	      		
	      }
	      if(cell!=null && geo==null)	{
			  	
	      		return new ExpressionNode(kernel, cell, Operation.FUNCTION, myList.getListElement(0)); 
	      		
	      }
			// create variable object for label to make sure
			// to handle lables like $A$1 correctly and keep the expression
			Variable geoVar = new Variable(kernel, label);
			ExpressionValue geoExp = geoVar.resolveAsExpressionValue(false);

			// numer of arguments
			int argNumber = myList.size();
      		
      		if (order > 0) { // derivative
      		      				// n-th derivative of geo
	      		ExpressionNode derivative =  new ExpressionNode(kernel, geoExp, Operation.DERIVATIVE, 
	      																new MyDouble(kernel, order));
      			if (geo.isGeoFunction()) {// function 
	      			return new ExpressionNode(kernel, derivative, Operation.FUNCTION, myList.getListElement(0)); 
	      		}
	      		else if (geo.isGeoCurveCartesian()) {// Cartesian curve 
      				return new ExpressionNode(kernel, derivative, Operation.VEC_FUNCTION, myList.getListElement(0)); 
	      		}       		
	      		else {
	                String [] str = { "FunctionExpected", funcName };
	                throw new MyParseError(loc, str);
	      		} 		
      		}
      		else { // no derivative: a(b)
	      		if (geo instanceof Evaluatable) // function 
	      			return new ExpressionNode(kernel, geoExp, Operation.FUNCTION, myList.getListElement(0)); 
				else if (geo instanceof GeoFunctionNVar) {
				  return new ExpressionNode(kernel, geoExp, Operation.FUNCTION_NVAR, myList);
				}
	      		else if (geo.isGeoCurveCartesian()) // vector function
	      		// at this point we have eg myList={{1,2}}, so we need first element of myList	      	      		
	      			return new ExpressionNode(kernel, geoExp, Operation.VEC_FUNCTION, myList.getListElement(0)); 

				// disabled, see #1115
				// doesn't work properly, creates spurious geos
	      		else if (geo.isGeoList()) // list1(1) to get first element of list1
	      		{
					//return new ExpressionNode(kernel, geoExp, Operation.ELEMENT_OF, myList); 
	      			String [] str = { "FunctionExpected", funcName };
	                throw new MyParseError(loc, str);
				}
				// a(b) becomes a*b because a is not a function, no list, and no curve
				// e.g. a(1+x) = a*(1+x) when a is a number      		   
	      		ExpressionNode expr =  new ExpressionNode(kernel, geoExp, Operation.MULTIPLY_OR_FUNCTION, myList.getListElement(0));
	      		undecided.add(expr);
	      		return expr; 

//	      		else {// error: no function
//	      			String [] str = { "FunctionExpected", funcName };
//	                throw new MyParseError(loc, str);
//	            }
	      	}
      }  
}


/**
 * cartesianvector =  ( expression, expression ) 
 */
VectorValue cartesianvector():
{     
    ExpressionValue x, y;                
}
{   
    // cartesian coordinates
  
    (  LOOKAHEAD(2147483647)
   ( "(" x = expression() <COMMA> y = expression() ")"  ) 	
    | 
    (  "(" x = expression() <VERTICAL_BAR> y = expression() ")" )
    )
        {  return new MyVecNode(kernel, x, y); }           
}

/**
 * cartesianvector3D =  ( expression, expression ) 
 */
Vector3DValue cartesianvector3D():
{     
    ExpressionValue x, y, z;                
}
{   
    // cartesian coordinates
  
    (  LOOKAHEAD(2147483647)
   ( "(" x = expression() <COMMA> y = expression() <COMMA> z = expression() ")"  ) 	
    | 
    (  "(" x = expression() <VERTICAL_BAR> y = expression() <VERTICAL_BAR> z = expression() ")" )
    )
        {  return new MyVec3DNode(kernel, x, y, z); }           
}

/**
 * polarvector = ( expression ; expression )             
 */
VectorValue polarvector():
{     
    ExpressionValue r, phi;                  
    MyVecNode v;
}
{   
    (  
      ( "(" r = expression() ";"  phi = expression() ")" )
    |
      ( <MP_POLARTOPOINT> r = expression() <COMMA> phi = expression() ")" )
    )   
        {                            
             v = new MyVecNode(kernel);                         
             v.setPolarCoords(r, phi);     
             return v;
        }          
}

/**
 * cartesianvector_special =  <LABEL>( expression | expression ) 
 */
ExpressionNode cartesianvector_special():
{     
   Token l;
    ExpressionValue x, y;                
}
{   
    // cartesian coordinates
    (   l = <FUNCTION_LABEL>  x = expression() <VERTICAL_BAR> y = expression() ")" )
        {         
        	ExpressionNode en =  new ExpressionNode(kernel, new MyVecNode(kernel, x, y)); 
        	en.setLabel(l.image.substring(0,l.image.length()-1));
        	return en;
        }           
}

/**
 * polarvector_special =  <LABEL>( expression ; expression ) 
 */
ExpressionNode polarvector_special():
{     
   Token l;
    ExpressionValue r, phi;                
}
{   
    // cartesian coordinates
    (   l = <FUNCTION_LABEL>  r = expression() ";" phi = expression() ")" )
        {         
            MyVecNode v = new MyVecNode(kernel);
            v.setPolarCoords(r, phi);
        	ExpressionNode en =  new ExpressionNode(kernel, v); 
        	en.setLabel(l.image.substring(0,l.image.length()-1));
        	return en;
        }           
}



